package pl.mg6.utils

import org.codehaus.groovy.ast.*
import org.codehaus.groovy.ast.expr.*
import org.codehaus.groovy.ast.stmt.BlockStatement
import org.codehaus.groovy.ast.stmt.ExpressionStatement
import org.codehaus.groovy.ast.stmt.ReturnStatement
import org.codehaus.groovy.classgen.BytecodeSequence

class AstComparator {

    static AstAssert assertThat(List<ASTNode> actual) {
        return new AstAssert(actual: actual)
    }

    static class AstAssert {

        List<ASTNode> actual

        void isEqualTo(List<ASTNode> expected) {
            assertSyntaxTree(expected, actual)
        }
    }

    private static void assertSyntaxTree(List<? extends ASTNode> expected, List<? extends ASTNode> actual) {
        if (expected.size() != actual.size()) {
            throw new RuntimeException("Node count different ${actual.size()} != ${expected.size()}. \nActual: ${actual.collect { "$it.lineNumber $it.columnNumber $it.text" }} \nExpect: ${expected.collect { "$it.lineNumber $it.columnNumber $it.text" }} ")
        }
        [expected, actual].transpose().each { ASTNode eNode, ASTNode aNode ->
            assertNode(eNode, aNode)
        }
    }

    private static assertNode(ASTNode eNode, ASTNode aNode) {
        if (eNode == null && aNode == null) {
            return
        }
        if (eNode == null || aNode == null) {
            throw new RuntimeException("One of the nodes is null, but should not. \nActual: $aNode \nExpect: $eNode")
        }
        if (eNode.lineNumber == -1) {
            // skip expected nodes without source
            // there is probably no need to check on them
            // as they are things and magic generated by Groovy
            return
        }
        println eNode.class.simpleName
        println aNode.class.simpleName
        if (eNode.class != aNode.class) {
            throw new RuntimeException("Different types of nodes. \nActual: ${aNode.class.simpleName} \nExpected: ${eNode.class.simpleName} ")
        }
        def name = eNode.class.simpleName
        if (nodeToActionMap.containsKey(name)) {
            def action = nodeToActionMap.get(name)
            action(eNode, aNode)
        } else {
            throw new RuntimeException("Missing definition for $name. Update nodeToActionMap")
        }
    }

    private static assertClassNode(ClassNode expected, ClassNode actual) {
        if (expected.name != actual.name) {
            throw new RuntimeException("Different class names. \nActual: $actual.name \nExpect: $expected.name ")
        }
    }

    private static Map<String, Closure> nodeToActionMap = [
            BlockStatement        : { BlockStatement expected, BlockStatement actual ->
                assertSyntaxTree(expected.statements, actual.statements)
            },
            ClassNode             : { ClassNode expected, ClassNode actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different class names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                assertSyntaxTree(expected.fields, actual.fields)
                assertSyntaxTree(expected.declaredConstructors, actual.declaredConstructors)
                assertSyntaxTree(expected.allDeclaredMethods, actual.allDeclaredMethods)
                assertSyntaxTree(expected.annotations, actual.annotations.findAll {
                    !it.classNode.name.startsWith("pl.mg6.grooid.")
                })
            },
            FieldNode             : { FieldNode expected, FieldNode actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different field names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                assertClassNode(expected.type, actual.type)
            },
            ConstructorNode       : { ConstructorNode expected, ConstructorNode actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different constructor names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                assertSyntaxTree(expected.parameters.toList(), actual.parameters.toList())
                assertSyntaxTree(expected.annotations, actual.annotations)
                assertNode(expected.code, actual.code)
            },
            MethodNode            : { MethodNode expected, MethodNode actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different method names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                assertSyntaxTree(expected.parameters.toList(), actual.parameters.toList())
                assertSyntaxTree(expected.annotations, actual.annotations)
                assertNode(expected.code, actual.code)
            },
            AnnotationNode        : { AnnotationNode expected, AnnotationNode actual ->
                assertClassNode(expected.classNode, actual.classNode)
                if (expected.allowedTargets != actual.allowedTargets) {
                    throw new RuntimeException("Different allowed targets. $expected.allowedTargets != $actual.allowedTargets")
                }
                if (expected.members.size() != actual.members.size()) {
                    throw new RuntimeException("Different annotation members count. ${expected.members.size()} != ${actual.members.size()}")
                }
                if (expected.members.keySet() != actual.members.keySet()) {
                    throw new RuntimeException("Different annotation members set. ${expected.members.keySet()} != ${actual.members.keySet()}")
                }
                def expectedMembers = expected.members.keySet().collect { expected.members[it] }
                def actualMembers = expected.members.keySet().collect { actual.members[it] }
                assertSyntaxTree(expectedMembers, actualMembers)
            },
            Parameter             : { Parameter expected, Parameter actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different parameter names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                assertClassNode(expected.type, actual.type)
            },
            ExpressionStatement   : { ExpressionStatement expected, ExpressionStatement actual ->
                assertNode(expected.expression, actual.expression)
            },
            ReturnStatement       : { ReturnStatement expected, ReturnStatement actual ->
                assertNode(expected.expression, actual.expression)
            },
            BinaryExpression      : { BinaryExpression expected, BinaryExpression actual ->
                if (expected.operation.type != actual.operation.type) {
                    throw new RuntimeException("Operations are different. $expected.operation != $actual.operation")
                }
                if (expected.operation.text != actual.operation.text) {
                    throw new RuntimeException("Operations are different. $expected.operation != $actual.operation")
                }
                assertNode(expected.leftExpression, actual.leftExpression)
                assertNode(expected.rightExpression, actual.rightExpression)
            },
            ConstantExpression    : { ConstantExpression expected, ConstantExpression actual ->
                if (expected.value != actual.value) {
                    throw new RuntimeException("Constant expressions are different. \nActual: $actual.value \nExpect: $expected.value")
                }
            },
            MethodCallExpression  : { MethodCallExpression expected, MethodCallExpression actual ->
                assertNode(expected.objectExpression, actual.objectExpression)
                assertNode(expected.arguments, actual.arguments)
                assertNode(expected.method, actual.method)
            },
            ListExpression        : { ListExpression expected, ListExpression actual ->
                assertSyntaxTree(expected.expressions, actual.expressions)
            },
            ArgumentListExpression: { ArgumentListExpression expected, ArgumentListExpression actual ->
                assertSyntaxTree(expected.expressions, actual.expressions)
            },
            FieldExpression       : { FieldExpression expected, FieldExpression actual ->
                assertClassNode(expected.type, actual.type)
                if (expected.fieldName != actual.fieldName) {
                    throw new RuntimeException("Field names are different. $expected.fieldName != $actual.fieldName")
                }
            },
            VariableExpression : { VariableExpression expected, VariableExpression actual ->
                if (expected.name != actual.name) {
                    throw new RuntimeException("Different variable names. \nActual: $actual.name \nExpect: $expected.name ")
                }
                //assertClassNode(expected.type, actual.type)
                assertNode(expected.initialExpression, actual.initialExpression)
            },
            PropertyExpression : { PropertyExpression expected, PropertyExpression actual ->
                assertNode(expected.objectExpression, actual.objectExpression)
                assertNode(expected.property, actual.property)
            },
            BytecodeSequence      : { BytecodeSequence expected, BytecodeSequence actual ->
                if (expected.instructions.size() != actual.instructions.size()) {
                    throw new RuntimeException("Instructions count different ${expected.instructions.size()} != ${expected.instructions.size()}.")
                }
                [expected.instructions, actual.instructions].transpose().each { eInstr, aInstr ->
                    if (eInstr.class != aInstr.class) {
                        throw new RuntimeException("Different instruction types. ${eInstr.class} != ${aInstr.class}")
                    }
                    if (eInstr instanceof ASTNode) {
                        assertNode(eInstr, aInstr)
                    }
                }
            }
    ]
}
